<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Moje Skórki</title>
  <style>
 #inventory {
  margin-left: 30px;
  margin-right: auto; /* po prawej stronie auto, żeby trzymał się lewej */
  max-width: 750px;
  min-width: 700px;
  border: 3px solid #000000;
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  padding: 10px;
  box-sizing: border-box;
  justify-content: flex-start;
}


.item-card {
  width: 200px;
  border: 1px solid #ccc;
  border-radius: 8px;
  background-color: #fff;
  padding: 10px;
  text-align: center;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.item-card img {
  width: 100px;
  height: auto;
  border-radius: 4px;
}




#available-skins {
  margin-right: 100px;
  margin-left: auto; /* po prawej stronie auto, żeby trzymał się lewej */
  max-width: 750px;
  min-width: 700px;
  border: 3px solid #000000;
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  padding: 10px;
  box-sizing: border-box;
  justify-content: flex-start;
}



#page-content {
  margin-top: 8%;
  display: flex;
  justify-content: space-between;
  align-items: flex-start; /* ważne – żeby góry były równo */
  gap: 20px;
  padding: 20px;
}

.item-card.selected {
  border: 2px solid green;
  background-color: #eaffea;
}
#selected-inventory, #selected-available {
      min-height: 150px;
      border: 2px dashed #444;
      padding: 10px;
      margin: 10px;
      max-width: 750px;
      min-width: 700px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    #upgrade-btn {
      font-size: 1.2em;
      padding: 10px 20px;
      margin: 20px;
      cursor: pointer;
    }
    #chance-percent {
      font-weight: bold;
    }


#upgrade-layout {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 30px;
  gap: 30px;
}

#selected-sections {
  display: flex;
  justify-content: space-between;
  width: 100%;
  padding: 0 40px;
  gap: 40px;
}

#selected-sections > div {
  flex: 1;
}

#selected-inventory,
#selected-available {
  min-height: 150px;
  border: 2px dashed #444;
  padding: 10px;
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  background-color: #f7f7f7;
}




* {
  box-sizing: border-box;
}
html, body {

  overflow-x: hidden; /* ukrywa poziomy scroll */
}













/* Kontener koła */
#wheel-container {
  width: 300px;
  height: 300px;
  margin: 20px auto;
  position: relative;
}

/* Canvas z kołem */
#wheel {
  width: 100%;
  height: 100%;
  display: block;
  border: 2px solid #444;
  border-radius: 50%;
}















  </style>
</head>
<body>
  <a href="/index.html">← Powrót</a>
<div id="wheel-container" style="position:relative; width:300px; height:300px; margin:auto;">
  <canvas id="wheel" width="300" height="300"></canvas>
  <div id="pointer" style="
    position:absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 0; 
    height: 0; 
    border-left: 15px solid transparent;
    border-right: 15px solid transparent;
    border-bottom: 30px solid black;
  "></div>
</div>





  <div id="upgrade-layout">
    <div id="selected-sections">
      <div>
        <h3>Zaznaczone z Inventory:</h3>
        <div id="selected-inventory"></div>
      </div>
      <div>
        <h3>Zaznaczone z Available:</h3>
        <div id="selected-available"></div>
      </div>
    </div>

    <div id="center-controls">
      <div style="margin-top: 20px; font-size: 1.3em;">
        Szansa na ulepszenie: <span id="chance-percent">0%</span>
      </div>
      <div style="margin-top: 20px;">
        <button id="upgrade-btn" disabled>Ulepsz skiny</button>
      </div>
    </div>
  </div>

  <h2>Twoje skiny</h2>
  <div id="page-content">
    <div>
      <h3>Inventory</h3>
      <div id="inventory"></div>
    </div>

    <div>
      <h3>Available Items</h3>
      <div id="available-skins"></div>
    </div>
  </div>
</div>



 <script>


 function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

 







    const userId = localStorage.getItem('user_id');

    if (!userId) {
      document.body.innerHTML = "<h2>Musisz być zalogowany, aby zobaczyć swoje skiny.</h2>";
      setTimeout(() => window.location.href = '/', 2000);
    }

    const inventoryContainer = document.getElementById('inventory');
    const availableContainer = document.getElementById('available-skins');
    const selectedInventory = document.getElementById('selected-inventory');
    const selectedAvailable = document.getElementById('selected-available');
    const chanceDisplay = document.getElementById('chance-percent');
    const upgradeBtn = document.getElementById('upgrade-btn');

    // Pobierz inventory użytkownika i wyświetl
    fetch(`/api/inventory/${userId}`)
      .then(res => res.json())
      .then(items => {
        if (!items.length) {
          inventoryContainer.textContent = 'Brak przedmiotów w ekwipunku.';
          return;
        }
        inventoryContainer.innerHTML = '';
        items.forEach(item => {
          const card = createItemCard(item.id, item.value, item.image_url, item.item_name);
          inventoryContainer.appendChild(card);
        });
      })
      .catch(err => {
        inventoryContainer.textContent = 'Błąd ładowania ekwipunku.';
        console.error(err);
      });





    // Pomocnicza funkcja do tworzenia karty
    function createItemCard(id, value, imgSrc, name) {
      const card = document.createElement('div');
      card.classList.add('item-card');
      card.dataset.id = id;
      card.dataset.value = value;

      const img = document.createElement('img');
      img.src = imgSrc;
      img.alt = name;

      const divName = document.createElement('div');
      divName.textContent = name;

      const divVal = document.createElement('div');
      divVal.innerHTML = `<strong>Wartość:</strong> ${parseFloat(value).toFixed(2)} zł`;

      card.appendChild(img);
      card.appendChild(divName);
      card.appendChild(divVal);

      return card;
    }









    // Zaznaczanie w inventory
    inventoryContainer.addEventListener('click', e => {
      const card = e.target.closest('.item-card');
      if (!card) return;

      card.classList.toggle('selected');
      refreshSelected('inventory');
      updateChance();
    });

    // Zaznaczanie w available items
    availableContainer.addEventListener('click', e => {
      const card = e.target.closest('.item-card');
      if (!card) return;

      card.classList.toggle('selected');
      refreshSelected('available');
      updateChance();
    });

    // Aktualizuje sekcje zaznaczonych skinów
    function refreshSelected(type) {
      let selectedCards, container;
      if (type === 'inventory') {
        selectedCards = inventoryContainer.querySelectorAll('.item-card.selected');
        container = selectedInventory;
      } else {
        selectedCards = availableContainer.querySelectorAll('.item-card.selected');
        container = selectedAvailable;
      }
      container.innerHTML = '';
      selectedCards.forEach(card => {
        const clone = card.cloneNode(true);
        clone.classList.remove('selected');
        container.appendChild(clone);
      });
      checkCanUpgrade();
    }

    // Oblicza i pokazuje szansę na ulepszenie
    function updateChance() {
      const invSelected = Array.from(inventoryContainer.querySelectorAll('.item-card.selected'));
      const availSelected = Array.from(availableContainer.querySelectorAll('.item-card.selected'));

      if (invSelected.length === 0 || availSelected.length === 0) {
        chanceDisplay.textContent = '0%';
        return;
      }

      const invSum = invSelected.reduce((sum, c) => sum + parseFloat(c.dataset.value), 0);
      const availSum = availSelected.reduce((sum, c) => sum + parseFloat(c.dataset.value), 0);

      if (availSum <= invSum) {
        chanceDisplay.textContent = '0%';
        return;
      }

      const chance = invSum / availSum;
      chanceDisplay.textContent = Math.round(chance * 100) + '%';
      drawWheel(Math.round(chance * 100));
    }

    // Sprawdza, czy można kliknąć ulepszanie
    function checkCanUpgrade() {
      const invCount = inventoryContainer.querySelectorAll('.item-card.selected').length;
      const availCount = availableContainer.querySelectorAll('.item-card.selected').length;
      upgradeBtn.disabled = invCount === 0 || availCount === 0;
    }







    // Obsługa kliknięcia ulepszania
    upgradeBtn.addEventListener('click', () => {
  const invSelectedIds = Array.from(inventoryContainer.querySelectorAll('.item-card.selected')).map(c => parseInt(c.dataset.id));
  const availSelectedIds = Array.from(availableContainer.querySelectorAll('.item-card.selected')).map(c => parseInt(c.dataset.id));

  if (invSelectedIds.length === 0 || availSelectedIds.length === 0) {
    alert('Zaznacz skiny z inventory i dostępne skiny do ulepszenia.');
    return;
  }

  upgradeBtn.disabled = true;
  upgradeBtn.textContent = 'Ulepszanie...';

  fetch('/api/upgrade', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      userId,
      inventorySkins: invSelectedIds,
      availableSkins: availSelectedIds
    })
  })
    .then(res => res.json())
    .then(data => {
      if (data.error) {
        alert('Błąd: ' + data.error);
        upgradeBtn.disabled = false;
        upgradeBtn.textContent = 'Ulepsz skiny';
        return;
      }

      // Uruchom animację koła
      spinWheel(data.success, () => {
        // Po zakończeniu animacji pokazujemy wynik
        if (data.success) {
          alert('Ulepszenie powiodło się! Szansa: ' + data.chance + '%');
        } else {
          alert('Ulepszenie nie powiodło się. Szansa: ' + data.chance + '%');
        }

        loadInventory();
        clearSelections();
        chanceDisplay.textContent = '0%';
        drawWheel(0); // zresetuj koło

        upgradeBtn.disabled = false;
        upgradeBtn.textContent = 'Ulepsz skiny';
      });
    })
    .catch(err => {
      alert('Błąd sieci: ' + err);
      upgradeBtn.disabled = false;
      upgradeBtn.textContent = 'Ulepsz skiny';
    });
});









    function loadInventory() {
      fetch(`/api/inventory/${userId}`)
        .then(res => res.json())
        .then(items => {
          inventoryContainer.innerHTML = '';
          if (!items.length) {
            inventoryContainer.textContent = 'Brak przedmiotów w ekwipunku.';
            return;
          }
          items.forEach(item => {
            const card = createItemCard(item.id, item.value, item.image_url, item.item_name);
            inventoryContainer.appendChild(card);
          });
        })
        .catch(err => {
          inventoryContainer.textContent = 'Błąd ładowania ekwipunku.';
          console.error(err);
        });
    }




function loadAvailableItems() {
  fetch('/api/available-items')
    .then(res => res.json())
    .then(items => {
      availableContainer.innerHTML = '';
      if (!items.length) {
        availableContainer.textContent = 'Brak dostępnych skinów.';
        return;
      }
      items.forEach(item => {
        const card = createItemCard(item.id, item.value, item.image_url, item.name); // UŻYWASZ item.name
        availableContainer.appendChild(card);
      });
    })
    .catch(err => {
      availableContainer.textContent = 'Błąd ładowania dostępnych skinów.';
      console.error(err);
    });
}



    function clearSelections() {
      inventoryContainer.querySelectorAll('.item-card.selected').forEach(c => c.classList.remove('selected'));
      availableContainer.querySelectorAll('.item-card.selected').forEach(c => c.classList.remove('selected'));
      selectedInventory.innerHTML = '';
      selectedAvailable.innerHTML = '';
      checkCanUpgrade();
    }





loadAvailableItems();




















const canvas = document.getElementById('wheel');
const ctx = canvas.getContext('2d');
let currentChance = 0;

// Rysuj koło z aktualną szansą
function drawWheel(chancePercent) {
  currentChance = chancePercent;
  const radius = canvas.width / 2;
  const thickness = 40; // grubość pierścienia

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Zielony (wygrana)
  const successAngle = (2 * Math.PI) * (chancePercent / 100);

  // Rysujemy pierścień zielony
  ctx.beginPath();
  ctx.fillStyle = '#28a745'; // zielony
  ctx.moveTo(radius + (radius), radius); // start na zewnętrznej krawędzi na prawo od środka (opcjonalne)

  // Zewnętrzny łuk
  ctx.arc(radius, radius, radius, -Math.PI / 2, -Math.PI / 2 + successAngle, false);

  // Łuk wewnętrzny (do środka koła)
  ctx.arc(radius, radius, radius - thickness, -Math.PI / 2 + successAngle, -Math.PI / 2, true);

  ctx.closePath();
  ctx.fill();

  // Czerwony (przegrana)
  ctx.beginPath();
  ctx.fillStyle = '#dc3545'; // czerwony
  ctx.moveTo(radius + (radius), radius);

  ctx.arc(radius, radius, radius, -Math.PI / 2 + successAngle, -Math.PI / 2 + 2 * Math.PI, false);

  ctx.arc(radius, radius, radius - thickness, -Math.PI / 2 + 2 * Math.PI, -Math.PI / 2 + successAngle, true);

  ctx.closePath();
  ctx.fill();
}

















function spinWheel(success, callback) {
  const duration = 3000; // czas animacji w ms
  const spins = 5;       // ile pełnych obrotów
  const radius = 360;

  // Przeliczamy currentChance na zakres 0-360 stopni
  const successDegree = (currentChance / 100) * radius;

  let finalAngle;

  if (success) {
    // Kąt losowy w zielonej części (0 do successDegree)
    const randomDegree = Math.random() * successDegree;
    // Obracamy tak, by pod trójkątem był ten zielony kąt
    finalAngle = spins * radius + (270 - randomDegree); // 270 = -90° + 360° (obrót)
  } else {
    // Kąt losowy w czerwonej części (successDegree do 360)
    const randomDegree = successDegree + Math.random() * (radius - successDegree);
    // Obracamy tak, by pod trójkątem był czerwony kąt
    finalAngle = spins * radius + (270 - randomDegree);
  }

  let start = null;

  function animate(timestamp) {
    if (!start) start = timestamp;
    const progress = timestamp - start;
    const ease = easeOutCubic(Math.min(progress / duration, 1));
    const angle = ease * finalAngle;

    canvas.style.transform = `rotate(${angle}deg)`;

    if (progress < duration) {
      requestAnimationFrame(animate);
    } else {
      canvas.style.transform = `rotate(${finalAngle}deg)`;
      callback();
    }
  }

  requestAnimationFrame(animate);
}

















  </script>


</body>
</html>
